# MySQL

Chapter 8 Optimization
file:///Users/zhang/rtfsc/refman-5.7-en.html-chapter/optimization.html#subquery-optimization

Chapter 14 The InnoDB Storage Engine
file:///Users/zhang/rtfsc/refman-5.7-en.html-chapter/innodb-storage-engine.html

Chapter 17 Group Replication
file:///Users/zhang/rtfsc/refman-5.7-en.html-chapter/group-replication.html

大厂必问的MySQL面试题
https://bbs.huaweicloud.com/blogs/323580

史上最详细的一线大厂Mysql面试题详解
https://juejin.cn/post/6844903824935632909

【总结】MySQL技术内幕六：InnoDB锁的实现原理
https://zhuanlan.zhihu.com/p/141862443

Mysql锁机制及原理简析
https://www.cnblogs.com/yinbiao/p/16273400.html

## 数据库范式 

第一范式（1NF）：数据库表中的字段都是*单一属性的，不可再分*。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
第二范式（2NF）：数据库表中**不**存在*非关键字段*对任一候选关键字段的*部分函数依赖*（*部分函数依赖*指的是存在组合关键字中的某些字段决定非关键字段的情况），也即*所有非关键字段都完全依赖于任意一组候选关键字*。
第三范式（3NF）：在第二范式的基础上，数据表中如果**不**存在*非关键字段*对任一候选关键字段的*传递函数依赖*则符合第三范式。所谓*传递函数依赖*，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

## 体系结构

- 讲一下MySQL架构？

MySQL主要分为 Server 层和存储引擎层：

Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
存储引擎： 主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。

Server 层基本组件

连接器： 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。
查询缓存: 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。
分析器: 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。
优化器： 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。
执行器： 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。

- 查询语句执行流程？

查询语句的执行流程如下：权限校验、查询缓存、分析器、*优化器*、权限校验、*执行器*、*引擎*。

举个例子，查询语句如下：

select * from user where id > 1 and name = '大彬';
首先检查权限，没有权限则返回错误；
MySQL8.0以前会查询缓存，缓存命中则直接返回，没有则执行下一步；
词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；
两种执行方案，先查 id > 1 还是 name = '大彬'，优化器根据自己的优化算法选择执行效率最好的方案；
校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。

- 更新语句执行过程？

更新语句执行流程如下：分析器、权限校验、*执行器*、*引擎*、*redo log（prepare状态）*、binlog、*redo log（commit状态）*

举个例子，更新语句如下：

update user set name = '大彬' where id = 1;
先查询到 id 为1的记录，有缓存会使用缓存。
拿到查询结果，将 name 更新为大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录redo log，此时redo log进入 prepare状态。
执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为commit状态。
更新完成。

为什么记录完redo log，不直接提交，而是先进入prepare状态？
假设先写redo log直接提交，然后写binlog，写完redo log后，机器挂了，binlog日志没有被写入，那么机器重启后，这台机器会通过redo log恢复数据，但是这个时候binlog并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。


## SQL

3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义
(1)、varchar与char的区别
char是一种固定长度的类型，varchar则是一种*可变长度*的类型
(2)、varchar(50)中50的涵义
最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者*在排序时会消耗更多内存*，因为order by col采用*fixed_length*计算col长度(memory引擎也一样)
(3)、int（20）中20的涵义
是指*显示字符的长度*
但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
20表示最大显示宽度为20，但*仍占4字节存储*，存储范围不变；
(4)、mysql为什么这么设计
对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；

23、简单说一说drop、delete与truncate的区
SQL中的drop、delete、truncate都表示删除，但是三者有一些差别
1、delete和truncate只删除表的数据不删除表的结构
2、速度,一般来说: drop> truncate >delete
3、delete语句是*dml*,这个操作会放到rollback segement中,事务提交之后才生效;
4、如果有相应的trigger,执行的时候将被触发. truncate,drop是*ddl*, 操作立即生效,*原数据不放到rollback segment中*,不能回滚. 操作不触发trigger.

24、drop、delete与truncate分别在什么场景之下使用？
1、不再需要一张表的时候，用drop
2、想删除部分数据行时候，用delete，并且带上where子句
3、保留表而删除所有数据的时候用truncate

25、超键、候选键、主键、外键分别是什么？
1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
2、候选键：是最小超键，即没有冗余元素的超键。
3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
4、外键：在一个表中存在的另一个表的主键称此表的外键。


26、什么是视图？以及视图的使用场景有哪些？
1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
2、*只暴露部分字段给访问者*，所以就建一个虚表，就是视图。
3、查询的数据来源于不同的表，而查询者希望以*统一的方式查询*，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

- exist和in的区别？

exists用于*对外表记录做筛选*。exists会*遍历外表*，将外查询表的每一行，代入内查询进行判断。
当exists里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。
反之如果exists里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。

select a.* from A a where exists(select 1 from B b where a.id=b.id) - 大True/False表 *E*XTERNAL

in是先把后边的语句查出来放到*临时表*中，然后*遍历临时表*，将临时表的每一行，代入外查询去查找。 - 小临时表 *I*NTERNAL

select * from A where id in (select id from B)

子查询的表比较大的时候，使用exists可以有效减少总的循环次数来提升速度；
当外查询的表比较大的时候，使用in可以有效减少对外查询表循环遍历来提升速度。

SQL语句中exists和in的区别
https://learnku.com/articles/56782
select * from A where id in(select id from B)
结论：in () 适合 B 表比 A 表数据小的情况

select a.* from A a where exists(select 1 from B b where a.id=b.id)
EXISTS 用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值 True 或 False。 EXISTS 指定一个子查询，检测 行 的存在。

结论：exists () 适合 B 表比 A 表数据大的情况


- having和where的区别？

二者作用的对象不同，where子句作用于表和视图，having作用于组。
where在数据分组前进行过滤，having在数据分组后进行过滤。

- 什么是分区表？

分区表是一个独立的逻辑表，但是底层由多个物理子表组成。

当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可。

**分区表类型**

按照*范围*分区。

```sql
CREATE TABLE test_range_partition(
       id INT auto_increment,
       createdate DATETIME,
       primary key (id,createdate)
   ) 
   PARTITION BY RANGE (TO_DAYS(createdate) ) (
      PARTITION p201801 VALUES LESS THAN ( TO_DAYS('20180201') ),
      PARTITION p201802 VALUES LESS THAN ( TO_DAYS('20180301') ),
      PARTITION p201803 VALUES LESS THAN ( TO_DAYS('20180401') ),
      PARTITION p201804 VALUES LESS THAN ( TO_DAYS('20180501') ),
      PARTITION p201805 VALUES LESS THAN ( TO_DAYS('20180601') ),
      PARTITION p201806 VALUES LESS THAN ( TO_DAYS('20180701') ),
      PARTITION p201807 VALUES LESS THAN ( TO_DAYS('20180801') ),
      PARTITION p201808 VALUES LESS THAN ( TO_DAYS('20180901') ),
      PARTITION p201809 VALUES LESS THAN ( TO_DAYS('20181001') ),
      PARTITION p201810 VALUES LESS THAN ( TO_DAYS('20181101') ),
      PARTITION p201811 VALUES LESS THAN ( TO_DAYS('20181201') ),
      PARTITION p201812 VALUES LESS THAN ( TO_DAYS('20190101') )
   );
在/var/lib/mysql/data/可以找到对应的数据文件，每个分区表都有一个使用#分隔命名的表文件：

   -rw-r----- 1 MySQL MySQL    65 Mar 14 21:47 db.opt
   -rw-r----- 1 MySQL MySQL  8598 Mar 14 21:50 test_range_partition.frm
   -rw-r----- 1 MySQL MySQL 98304 Mar 14 21:50 test_range_partition#P#p201801.ibd
   -rw-r----- 1 MySQL MySQL 98304 Mar 14 21:50 test_range_partition#P#p201802.ibd
   -rw-r----- 1 MySQL MySQL 98304 Mar 14 21:50 test_range_partition#P#p201803.ibd
...
```

*list分区*

对于List分区，分区字段必须是已知的，如果插入的字段不在分区时枚举值中，将无法插入。

```sql
create table test_list_partiotion
   (
       id int auto_increment,
       data_type tinyint,
       primary key(id,data_type)
   )partition by list(data_type)
   (
       partition p0 values in (0,1,2,3,4,5,6),
       partition p1 values in (7,8,9,10,11,12),
       partition p2 values in (13,14,15,16,17)
   );
```

*hash分区*

可以将数据均匀地分布到预先定义的分区中。

```sql
create table test_hash_partiotion
   (
       id int auto_increment,
       create_date datetime,
       primary key(id,create_date)
   )partition by hash(year(create_date)) partitions 10;
```

- 19、什么是存储过程？有哪些优缺点？
存储过程是一些预编译的SQL语句。

1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
2、存储过程是一个*预编译的代码块*，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以*降低网络通信量*，提高通信速率,可以一定程度上确保数据安全


## 存储引擎

### Myisam和Innodb索引实现的不同（存储结构）

https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html

  每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。
  .frm文件存储表定义。
  数据文件的扩展名为.MYD (MYData)。
  索引文件的扩展名是.MYI (MYIndex)。

https://blog.csdn.net/donghaixiaolongwang/article/details/60751543

MyISAM引擎使用B+ Tree作为索引结构，叶节点的data域存放的是**数据记录的地址**。
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

第一个重大区别是InnoDB的**数据文件本身就是索引文件**
第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录*主键的值*而不是地址。


2、MySQL中myisam与innodb的区别，至少5点
(1)、问5点不同；
1>.InnoDB支持**事务**，而MyISAM不支持事务
2>.InnoDB支持**行级锁**，而MyISAM支持表级锁
3>.InnoDB支持**MVCC**, 而MyISAM不支持
4>.InnoDB支持**外键**，而MyISAM不支持
5>.InnoDB**不支持全文索引**，而MyISAM支持。

(2)、innodb引擎的4大特性

插入缓冲（insert buffer) https://www.cnblogs.com/chenpingzhao/p/4883884.html
   物理页, 受影响的二级索引页不在buffer pool中时, 缓存索引页的变化, 当数据页读入buffer pool时进行合并操作. - change buffer
二次写(double write) https://www.cnblogs.com/geaozhang/p/7241744.html
  内存中的doublewrite buffer，其大小为2MB
  共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M
自适应哈希索引(ahi) https://blog.51cto.com/BugMaker/5588473
  如果检测到某个*二级索引*不断被使用，二级索引成为热数据，那么InnoDB会根据在二级索引树上的索引值在构建一个哈希索引来加速搜索（只适用于等值比较）
预读(read ahead)

(3)、2者select count(*)哪个更快，为什么
myisam更快，因为myisam内部维护了一个*计数器*，可以直接调取。

- 常见的存储引擎有哪些？

MySQL中常用的四种存储引擎分别是： MyISAM、InnoDB、MEMORY、ARCHIVE。MySQL 5.5版本后默认的存储引擎为InnoDB。

InnoDB存储引擎

InnoDB是MySQL默认的事务型存储引擎，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。

优点：支持事务和崩溃修复能力；引入了行级锁和外键约束。
缺点：占用的数据空间相对较大。
适用场景：需要事务支持，并且有较高的并发读写频率。

MyISAM存储引擎
数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件.MYD和索引文件.MYI。
优点：访问速度快。
缺点：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。
适用场景：对事务完整性没有要求；表的数据都会只读的。

MEMORY存储引擎

MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。

MEMORY引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。

优点：访问速度较快。

缺点：

哈希索引数据不是按照索引值顺序存储，无法用于排序。
不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。
只支持等值比较，不支持范围查询。
当出现哈希冲突时，存储引擎需要遍历链表中所有的行指针，逐行进行比较，直到找到符合条件的行。
ARCHIVE存储引擎

ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。

*MyISAM和InnoDB的区别？*
是否支持行级锁 : MyISAM 只有表级锁，而InnoDB 支持行级锁和表级锁，默认为行级锁。
是否支持事务和崩溃后的安全恢复： MyISAM 不提供事务支持。而InnoDB提供事务支持，具有事务、回滚和崩溃修复能力。
是否支持外键： MyISAM不支持，而InnoDB支持。
是否支持MVCC ：MyISAM不支持，InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效。
MyISAM不支持聚集索引，InnoDB支持聚集索引。

### MySQL 的 NULL 值是怎么存储的？

https://www.cnblogs.com/xiaolincoding/p/16941244.html

MySQL 的 NULL 值会占用空间吗？
MySQL 怎么知道 varchar(n) 实际占用数据的大小？
varchar(n) 中 n 最大取值为多少？
行溢出后，MySQL 是怎么处理的？


InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。

- *Redundant* 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
- 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 *Compact* 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。
- *Dynamic* 和 *Compressed* 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分

*记录的额外信息*包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。
如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。
二进制位的值为1时，代表该列的值为NULL。
二进制位的值为0时，代表该列的值不为NULL。

记录头信息中包含的内容很多，这里说几个比较重要的：
delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

*记录真实数据*部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。
一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。

NULL值列表会占用 1 字节空间

每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：
条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；
条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384字节，而一个 varchar(n) 类型的列最多可以存储 65532字节，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会发生行溢出，多的数据就会存到另外的「溢出页」中。

- GROUP BY

mysql group by排序
https://juejin.cn/post/7078482074696417311

Previously (MySQL 5.7 and lower), GROUP BY sorted implicitly under certain conditions. In MySQL 8.0, that no longer occurs, so specifying ORDER BY NULL at the end to suppress implicit sorting (as was done previously) is no longer necessary. However, query results may differ from previous MySQL versions. To produce a given sort order, provide an ORDER BY clause.


## 事务

21、什么是事务？
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。


ACID特性：

*原子性（Atomicity）*：事务要么全部完成，要么全部取消。如果事务崩溃，数据库的状态要回滚到事务之前
*一致性（Consistency）*：只有合法的数据（依照关系约束和函数约束）才能写入数据库
*隔离性（Isolation）*：如果两个事务T1和T2同时运行，不论T1和T2谁先结束，事务T1和T2执行的最终结果是相同的
*持久性（Durability）*：一旦事务交，不管发生什么（崩溃或者出错），数据都保存在数据库中


4、问了innodb的事务与日志的实现方式


(2)、事务的4种隔离级别
隔离级别
读未提交(RU)
读已提交(RC)
可重复读(RR)
串行

事务的四大特性？
事务特性ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

*原子性*是指事务包含的所有操作要么全部成功，要么全部失败回滚。
*一致性*是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
*隔离性*。跟隔离级别相关，如read committed，一个事务只能读到已经提交的修改。
*持久性*是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
事务隔离级别有哪些？
先了解下几个概念：脏读、不可重复读、幻读。

*脏读*是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
*不可重复读*是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务*修改*了数据并提交了。
*幻读*是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内*插入*了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。
不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。

事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。

MySQL数据库为我们提供的四种隔离级别：

Serializable (串行化)：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
Repeatable read (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。
Read committed (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
Read uncommitted (读未提交)：所有事务都可以看到其他未提交事务的执行结果。
查看隔离级别：
select @@transaction_isolation;
设置隔离级别：
set session transaction isolation level read uncommitted;

### 事务日志

- (1)、有多少种日志；

*错误日志*：记录出错信息，也记录一些警告信息或者正确的信息。
*查询日志*：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
*慢查询日志*：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
*二进制日志*：记录对数据库执行更改的所有操作。
*中继日志*：中继日志也是二进制日志，用来给slave 库恢复
*事务日志*：重做日志redo和回滚日志undo

- (3)、事务是如何通过日志来实现的，说得越深入越好。

事务日志是通过*redo*和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的*lsn*(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的*日志缓存*里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲*写入磁盘*（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”

- bin log/redo log/undo log

MySQL日志主要包括查询日志、慢查询日志、事务日志、错误日志、二进制日志等。其中比较重要的是 bin log（二进制日志）和 redo log（重做日志）和 undo log（回滚日志）。

bin log
bin log是MySQL数据库级别的文件，记录对MySQL数据库执行修改的所有操作，不会记录select和show语句，主要用于恢复数据库和同步数据库。

redo log
redo log是innodb引擎级别，用来记录innodb存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障，innoDB存储引擎会使用redo log恢复到发生故障前的时刻，以此来保证数据的完整性。将参数innodb_flush_log_at_tx_commit设置为1，那么在执行commit时会将redo log同步写到磁盘。

undo log
除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它保留了记录修改前的内容。通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。

bin log和redo log有什么区别？
bin log会记录所有日志记录，包括InnoDB、MyISAM等存储引擎的日志；redo log只记录innoDB自身的事务日志。
bin log只在事务提交前写入到磁盘，一个事务只写一次；而在事务进行过程，会有redo log不断写入磁盘。
bin log是逻辑日志，记录的是SQL语句的原始逻辑；redo log是物理日志，记录的是在某个数据页上做了什么修改。


- 5、MySQL binlog的几种日志录入格式以及区别

*Statement*：每一条会修改数据的sql都会记录在binlog中。
优点：*不需要记录每一行的变化，减少了binlog日志量*，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些*相关信息*，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， 1454098，以及user-defined functions(udf)会出现问题).
使用以下函数的语句也无法被复制：
LOAD_FILE()
*UUID()*
USER()
FOUND_ROWS()
SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)

同时在INSERT …SELECT 会产生比 RBR 更多的行级锁

*Row*:不记录sql语句上下文相关信息，仅*保存哪条记录被修改*。
优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 *每一行数据修改的细节*。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。

*Mixedlevel*: 是以上两种level的*混合使用*，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。


#### 精讲 MySQL 事务日志：redo log 和 undo log

https://blog.51cto.com/u_11475121/2957024

redo log通常是*物理日志*，记录的是*数据页的物理修改*，而不是某一行或某几行修改成怎样怎样，它用来*恢复*提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
undo用来*回滚*行记录到某个版本。undo log一般是*逻辑日志*，根据每行记录进行记录
binlog是在*存储引擎的上层*产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。
而redo log是*innodb层*产生的，只记录该存储引擎中表的修改。并且binlog*先于*redo log被记录。

redo log包括两部分：一是*内存中的日志缓冲(redo log buffer)*，该部分日志是易失性的；二是*磁盘上的重做日志文件(redo log file)*，该部分日志是持久的.
在概念上，innodb通过**force log at commit**机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。

**LSN**称为日志的逻辑序列号(log sequence number)，在innodb存储引擎中，lsn占用8个字节。

innodb存储引擎对undo的管理采用段的方式。**rollback segment**称为回滚段，每个回滚段中有1024个undo log segment.

mysql物理存储（页区段）
https://www.cnblogs.com/gered/p/13803642.html
表空间 > 段 > 区/块 > 页 > 行

### MVCC

https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html

隐式字段
每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段
**DB_ROW_ID** 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
**DB_TRX_ID** 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
**DB_ROLL_PTR** 7byte, 回滚指针，指向这条记录的上一个版本（存储于**rollback segment**里）
**DELETED_BIT** 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了

undo log主要分为3种：
*Insert* undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
*Update* undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
*Delete* undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。

对MVCC有帮助的实质是**update undo log** ，undo log实际上就是存在rollback segment中旧记录链

什么是**Read View**，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

我们可以把Read View简单的理解成有三个全局属性
**trx_list** 未提交事务ID列表，用来维护Read View生成时刻系统**正活跃的事务ID**         - 含当前事务
**up_limit_id** 记录trx_list列表中事务ID**最小的ID**
**low_limit_id** ReadView生成时刻系统**尚未分配的下一个事务ID**，也就是目前已出现过的事务ID的最大值+1

- 首先比较*DB_TRX_ID < up_limit_id*, 如果小于，则当前事务*能看到*DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
- 接下来判断 *DB_TRX_ID >= low_limit_id* , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成*后*才出现的，那对当前事务肯定*不可见*，如果小于则进入下一个判断
- 判断*DB_TRX_ID 是否在活跃事务之中*，trx_list.contains(DB_TRX_ID)，
  如果*在*，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是*看不见的*；
  如果*不在*，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是*能看见的*.

在**RC**隔离级别下，是每个快照读都会生成并获取*最新的Read View*；
而在**RR**隔离级别下，则是同一个事务中的*第一个快照读*才会创建Read View, 之后的快照读获取的都是同一个Read View。

#### MVCC 实现原理？
MVCC(Multiversion concurrency control) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过*read view*和*版本链*找到对应版本的数据。
作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。

MVCC 实现原理如下：
MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。

DB_TRX_ID：当前事务id，通过事务id的大小判断事务的时间顺序。 - ???
DB_ROLL_PRT：回滚指针，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成undo log版本链。
DB_ROW_ID：主键，如果数据表没有主键，InnoDB会自动生成主键。
每条表记录大概是这样的：

使用事务更新行记录的时候，就会生成版本链，执行过程如下：

用排他锁锁住该行；
将该行原本的值拷贝到undo log，作为旧版本用于回滚；
修改当前行的值，生成一个新版本，更新事务id，使回滚指针指向旧版本的记录，这样就形成一条版本链。
下面举个例子方便大家理解。

1、初始数据如下，其中DB_ROW_ID和DB_ROLL_PTR为空。
2、事务A对该行数据做了修改，将age修改为12，效果如下：
3、之后事务B也对该行记录做了修改，将age修改为8，效果如下：
4、此时undo log有两行记录，并且通过回滚指针连在一起。

接下来了解下read view的概念。

read view可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取某时刻t的数据时，到t时间点拍的“照片”上取数据。

在read view内部维护一个*活跃事务链表*，表示生成read view的时候还在活跃的事务。这个链表包含在创建read view之前还未提交的事务，不包含创建read view之后提交的事务。

不同隔离级别创建read view的时机不同。

read committed：*每次执行select都会创建新的read_view*，保证能读取到其他事务已经提交的修改。
repeatable read：在一个事务范围内，*第一次select时更新这个read_view，以后不会再更新*，后续所有的select都是复用之前的read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。

read view的记录筛选方式

前提：
DATA_TRX_ID 表示每个数据行的最新的事务ID；
up_limit_id表示当前快照中的最先开始的事务；
low_limit_id表示当前快照中的最慢开始的事务，即最后一个事务。

如果DATA_TRX_ID < up_limit_id：说明在创建read view时，修改该数据行的事务已提交，该版本的记录可被当前事务读取到。
如果DATA_TRX_ID >= low_limit_id：说明当前版本的记录的事务是在创建read view之后生成的，该版本的数据行不可以被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本的记录对当前事务的可见性。
如果up_limit_id <= DATA_TRX_ID < low_limit_id：需要在活跃事务链表中查找是否存在ID为DATA_TRX_ID的值的事务。
   如果存在，因为在活跃事务链表中的事务是未提交的，所以该记录是不可见的。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。
   如果不存在，说明事务trx_id 已经提交了，这行记录是可见的。

总结：InnoDB 的MVCC是通过 read view 和版本链实现的，版本链保存有历史版本记录，通过read view 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。

快照读和当前读
表记录有两种读取方式。

快照读：读取的是*快照版本*。普通的SELECT就是快照读。通过mvcc来进行并发控制的，不用加锁。
当前读：读取的是*最新版本*。UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。

快照读情况下，InnoDB通过mvcc机制避免了幻读现象。而mvcc机制无法避免当前读情况下出现的幻读现象。
因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。

下面举个例子说明下：

1、首先，user表只有两条记录，具体如下：
2、事务a和事务b同时开启事务start transaction；
3、事务a插入数据然后提交；

insert into user(user_name, user_password, user_mail, user_state) values('tyson', 'a', 'a', 0);
4、事务b执行全表的update；

update user set user_name = 'a';
5、事务b然后执行查询，查到了事务a中插入的数据。（下图左边是事务b，右边是事务a。事务开始之前只有两条记录，事务a插入一条数据之后，事务b查询出来是三条数据）

以上就是当前读出现的幻读现象。

那么MySQL是如何避免幻读？

在快照读情况下，MySQL通过*mvcc*来避免幻读。
在当前读情况下，MySQL通过*next-key*来避免幻读（加行锁和间隙锁来实现的）。
next-key包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。

Serializable隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。


### 锁

- 乐观锁和悲观锁是什么？

数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观锁和悲观锁是并发控制主要采用的技术手段。

悲观锁：假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加version字段，在修改提交之前检查version与原来取到的version值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用版本号机制或CAS算法实现。

28、数据库的乐观锁和悲观锁是什么？
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
悲观锁：假定会发生并发冲突，*屏蔽一切可能违反数据完整性的操作*
乐观锁：假设不会发生并发冲突，*只在提交操作时检查*是否违反数据完整性。


- 共享锁和排他锁

SELECT 的读取锁定主要分为两种方式：*共享锁*和*排他锁*。

select * from table where id<6 lock in share mode;--共享锁
select * from table where id<6 for update;--排他锁
这两种方式主要的不同在于LOCK IN SHARE MODE多个事务同时更新同一个表单时很容易造成死锁。

申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被commit语句或rollback语句结束为止。

SELECT... FOR UPDATE 使用注意事项：

for update 仅适用于innodb，且必须在事务范围内才能生效。
根据主键进行查询，查询条件为like或者不等于，主键字段产生表锁。
根据非索引字段进行查询，会产生表锁。

#### mysql死锁怎么解决

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

**设置事务等待锁的超时时间**。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。

**开启主动死锁检测**。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。

**尽量降低锁的范围**.

尽量让数据表中的数据检索都*通过索引*来完成，避免无效索引导致行锁升级为表锁。
尽量**减少查询条件的范围**，尽量避免间隙锁或缩小间隙锁的范围。
尽量**控制事务的大小**，减少一次事务锁定的资源数量，缩短锁定资源的时间。
如果一条SQL语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行。 
尽可能使用低级别的事务隔离机制。

## SQL优化 

7、sql优化各种方法
(1)、explain出来的各种item的意义；
select_type
表示查询中每个select子句的类型
type
表示MySQL在表中找到所需行的方式，又称“访问类型”
possible_keys
指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
key
显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL
key_len
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
ref
表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
Extra
包含不适合在其他列中显示但十分重要的额外信息

(2)、profile的意义以及使用场景；
查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等

### 索引

22、使用索引查询一定能提高查询的性能吗？为什么
通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.
1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:
2、基于一个*范围*的检索,一般查询返回结果集小于表中记录数的30%
3、基于非唯一性索引的检索


索引
什么是索引？
索引是存储引擎用于提高数据库表的访问速度的一种数据结构。

索引的优缺点？
优点：
加快数据查找的速度
为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度
加快表与表之间的连接
缺点：
建立索引需要占用物理空间
会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长
索引的作用？
数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。

什么情况下需要建索引？
经常用于查询的字段
经常用于连接的字段建立索引，可以加快连接的速度
经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度

什么情况下不建索引？
where条件中用不到的字段不适合建立索引
表记录较少
需要经常增删改
参与列计算的列不适合建索引
区分度不高的字段不适合建立索引，如性别等

索引的数据结构
索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。
InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。

**B+树索引**
B+ 树是基于B 树和*叶子节点顺序访问指针*进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高*区间查询*的性能。

在 B+ 树中，节点中的 key 从左到右递增排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

进行查找操作时，首先在根节点进行*二分查找*，找到key所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的数据项。

MySQL 数据库使用最多的索引类型是BTREE索引，底层基于B+树数据结构来实现。

```shell
mysql> show index from blog\G;
*************************** 1. row ***************************
        Table: blog
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: blog_id
    Collation: A
  Cardinality: 4
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
```

**哈希索引**
哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于*精确查找*。

Hash索引和B+树索引的区别？
哈希索引不支持排序，因为哈希表是无序的。
哈希索引不支持范围查找。
哈希索引不支持模糊查询及多列索引的最左前缀匹配。
因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。

为什么B+树比B树更适合实现数据库索引？
由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是*B树因为其分支结点同样存储着数据*，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。

B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。
B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

索引有什么分类？
1、*主键索引*：名为primary的唯一非空索引，不允许有空值。
2、*唯一索引*：索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一约束的列可以为null且可以存在多个null值。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。创建唯一索引的SQL语句如下：
ALTER TABLE table_name
ADD CONSTRAINT constraint_name UNIQUE KEY(column_1,column_2,...);
3、*组合索引*：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时需遵循最左前缀原则。
4、*全文索引*：只有在MyISAM引擎上才能使用，只能在CHAR、VARCHAR和TEXT类型字段上使用全文索引。

什么是最左匹配原则？
如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(>、<、between、like)就会停止匹配，后面的字段不会用到索引。

对(a,b,c)建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。如果查询条件为a = 1 and b > 2 and c = 3，那么a、b个字两段能用到索引，而c无法使用索引，因为b字段是范围查询，导致后面的字段无法使用索引。

如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行排序）。

当a的值确定的时候，b是有序的。例如a = 1时，b值为1，2是有序的状态。当执行a = 1 and b = 2时a和b字段能用到索引。而对于查询条件a < 4 and b = 2时，a字段能用到索引，b字段则用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b的值不是有序的，因此b字段无法使用索引。

什么是*聚集索引*？
InnoDB使用表的主键构造*主键索引树*，同时*叶子节点中存放的即为整张表的记录数据*。聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。

聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。

对于InnoDB来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引。如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。

什么是覆盖索引？
select的数据列只用从索引中就能够取得，*不需要回表进行二次查询*，也就是说查询列要被所使用的索引覆盖。对于innodb表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而*哈希索引、全文索引不存储索引列的值*，所以MySQL使用b+树索引做覆盖索引。

对于使用了覆盖索引的查询，在查询前面使用explain，输出的extra列会显示为using index。

比如user_like 用户点赞表，组合索引为(user_id, blog_id)，user_id和blog_id都不为null。

explain select blog_id from user_like where user_id = 13;
explain结果的Extra列为Using index，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过索引查找就能直接找到符合条件的数据，不需要回表查询数据。

explain select user_id from user_like where blog_id = 1;
explain结果的Extra列为Using where; Using index， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过索引扫描找到符合条件的数据，也不需要回表查询数据。



索引的设计原则？
索引列的*区分度*越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。
尽量使用*短索引*，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。
索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。
利用*最左前缀原则*。

索引什么时候会失效？
导致索引失效的情况：
对于组合索引，不是使用组合索引最左边的字段，则不会使用索引
以%开头的like查询如%abc，无法使用索引；非%开头的like查询如abc%，相当于范围查询，会使用索引
查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效
判断索引列是否不等于某个值时
对索引列进行运算
查询条件使用or连接，也会导致索引失效

什么是前缀索引？
有时需要在*很长的字符列*上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。
前缀索引是指*对文本或者字符串的前几个字符建立索*引，这样*索引的长度更短*，查询速度更快。
创建前缀索引的关键在于选择足够长的前缀以保证较高的索引选择性。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。

建立前缀索引的方式：
```sql
// email列创建前缀索引
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
```

20、索引是什么？有什么作用以及优缺点？
1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构
2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。

MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引
1、索引*加快数据库的检索速度*
2、索引*降低了插入、删除、修改等维护任务的速度*
3、唯一索引可以确保每一行数据的唯一性
4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
5、索引需要*占物理和数据空间*


### MySQL索引失效

当我们使用左或者左右模糊匹配的时候，也就是 *like %xx* 或者 like %xx%这两种方式都会造成索引失效；
当我们在查询条件中对索引列使用*函数*，就会导致索引失效。
当我们在查询条件中对索引列进行*表达式计算*，也是无法走索引的。
MySQL 在遇到*字符串和数字比较*的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
联合索引要能正确使用需要遵循*最左匹配原则*，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
在 WHERE 子句中，如果在 *OR 前的条件列是索引列，而在 OR 后的条件列不是索引列*，那么索引会失效。

1.or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效;
2.复合索引未用左列字段，即不是使用第一列索引，索引失效;
3.like以%开头，当like前缀没有%，后缀有%时，索引有效;
4.需要类型转换;
5.where中索引列有运算，或者索引列使用了函数;;
6.where中在索引字段上使用not，<>，!=。
7.如果mysql觉得*全表扫描更快*时（数据少）;
8. 在索引列上使用 IS NULL 或 IS NOT NULL操作。

### 分库分表
当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。

数据切分可以分为两种方式：垂直划分和水平划分。

垂直划分

垂直划分数据库是根据业务进行划分，例如购物场景，可以将库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，可以将商品基本信息和商品描述拆分成两张表。

优点：行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。

缺点：
主键出现冗余，需要管理冗余列；
会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力；
依然存在单表数据量过大的问题。
水平划分

水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。

优点：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。

缺点：
分片事务一致性难以解决
跨节点join性能差，逻辑复杂
数据分片在扩容时需要迁移

### 大表怎么优化？
某个表有近千万数据，查询比较慢，如何优化？

当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下：
限定数据的范围。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内；
读写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
通过分库分表的方式进行优化，主要有垂直拆分和水平拆分。

## 运维

### es和mysql如何同步

**双写**。在代码中先向Mysql中写入数据，然后紧接着向Es中写入数据。这个方法的缺点是代码严重耦合，需要手动维护Mysql和Es数据关系，非常不便于维护。
**发MQ，异步执行**。在执行完向Mysql中写入数据的逻辑后，发送MQ，告诉消费端这个数据需要写入Es，消费端收到消息后执行向Es写入数据的逻辑。
优点是Mysql和Es数据维护分离，开发Mysql和Es的人员只需要关心各自的业务。
缺点是依然需要维护发送、接收MQ的逻辑，并且引入了MQ组件，增加了系统的复杂度。
**基于Mysql表定时扫描同步**。使用Datax进行*全量数据同步*
这个方式优点是可以完全不用写维护数据关系的代码，各自只需要关心自己的业务，对代码侵入性几乎为零。
缺点是Datax是一种全量同步数据的方式，不使用实时同步。如果系统对*数据时效性不强*，可以考虑此方式。
**基于Binlog实时同步**。使用Canal进行实时数据同步
各自只需要关心自己的业务，对代码侵入性几乎为零。
与Datax不同的是: Canal是一种实时同步数据的方式，对*数据时效性较强*的系统，我们会采用Canal来进行实时数据同步。

### MySQL的复制原理以及流程
基本原理流程，3个线程以及之间的关联；
主：**binlog线程**——记录下所有改变了数据库数据的语句，放进master上的binlog中；
从：**io线程**——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
从：**sql执行线程**——执行relay log中的语句；


- 什么是MySQL主从同步？

主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。

因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。

- 为什么要做主从同步？

读写分离，使数据库能支撑更大的并发。
在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。
数据备份，保证数据的安全。

### 其他

- 用过processlist吗？
show processlist 或 show full processlist 可以查看当前 MySQL 是否有压力，正在运行的SQL，有没有慢SQL正在执行。返回参数如下：

id：线程ID，可以用kill id杀死某个线程
db：数据库名称
user：数据库用户
host：数据库实例的IP
command：当前执行的命令，比如Sleep，Query，Connect等
time：消耗时间，单位秒
state：执行状态，主要有以下状态：
Sleep，线程正在等待客户端发送新的请求
Locked，线程正在等待锁
Sending data，正在处理SELECT查询的记录，同时把结果发送给客户端
Kill，正在执行kill语句，杀死指定线程
Connect，一个从节点连上了主节点
Quit，线程正在退出
Sorting for group，正在为GROUP BY做排序
Sorting for order，正在为ORDER BY做排序
info：正在执行的SQL语句

- 6、MySQL数据库cpu飙升到500%的话他怎么处理？

1、列出所有进程 *show processlist*,观察所有进程 ,多秒没有状态变化的(干掉)
2、查看*超时日志或者错误日志* (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)

- 8、备份计划，mysqldump以及xtranbackup的实现原理
(1)、备份计划；
这里每个公司都不一样，您别说那种1小时1全备什么的就行
(2)、备份恢复时间；
这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考
20G的2分钟（mysqldump）
80G的30分钟(mysqldump)
111G的30分钟（mysqldump)
288G的3小时（xtra)
3T的4小时（xtra)
逻辑导入时间一般是备份时间的5倍以上
(3)、xtrabackup实现原理
在InnoDB内部会维护一个*redo日志文件*，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。

MySQLDump的备份小技巧
https://www.51cto.com/article/672563.html
mysqldump 是 MySQL 系统自带的逻辑备份工具，主要用于转储数据库。它主要产生一系列的 SQL 语句，可以封装到文件，该文件包含重建数据库所需要的 SQL 命令如 CREATE DATABASE ，CREATE TABLE ，INSERT 等等。当我们需要还原这些数据时，只需要执行此文件，即可将对应的数据还原。

xtrabackup原理详解
https://blog.51cto.com/xxr007/3181157

- 9、mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？
**--skip-extended-insert**

```sql
[root@helei-zhuanshu ~]# mysqldump -uroot -p helei --skip-extended-insert
Enter password:
KEY `idx_c1` (`c1`),
KEY `idx_c2` (`c2`)
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;

/*!40101 SET character_set_client = @saved_cs_client */;
--
-- Dumping data for table `helei`
--
LOCK TABLES `helei` WRITE;

/*!40000 ALTER TABLE `helei` DISABLE KEYS */;

INSERT INTO `helei` VALUES (1,32,37,38,'2016-10-18 06:19:24','susususususususususususu');
INSERT INTO `helei` VALUES (2,37,46,21,'2016-10-18 06:19:24','susususususu');
INSERT INTO `helei` VALUES (3,21,5,14,'2016-10-18 06:19:24','susu');
```

- 10、500台db，在最快时间之内重启

可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器

- 11、innodb的读写参数优化
(1)、读取参数
global buffer pool以及 local buffer；
(2)、写入参数；
innodb_flush_log_at_trx_commit
innodb_buffer_pool_size
(3)、与IO相关的参数；
innodb_write_io_threads = 8
innodb_read_io_threads = 8
innodb_thread_concurrency = 0
(4)、缓存参数以及缓存的适用场景。
query cache/query_cache_type
并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更
第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。
第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。
第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache

- 12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？
监控的工具有很多，例如zabbix，lepus，我这里用的是lepus

- 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？
主从一致性校验有多种工具 例如checksum、mysqldiff、*pt-table-checksum*等

- 14、你们数据库是否支持emoji表情，如果不支持，如何操作？
如果是utf8字符集的话，需要升级至*utf8_mb4*方可支持

- 15、你是如何维护数据库的数据字典的？
这个大家维护的方法都不同，我一般是直接在生产库进行注释，利用工具导出成excel方便流通。

- 16、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问
*拆带来的问题：连接消耗 + 存储拆分空间*；
*不拆可能带来的问题：查询性能*；
1、如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗
2、如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择

- 17、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？
InnoDB是基于*索引*来完成行锁
例: select * from tab_with_index where id = 1 for update;
for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,
如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起

- 18、开放性问题：据说是腾讯的
一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。

1、如果A表TID是自增长,并且是连续的,B表的ID为索引

select * from a,b where a.tid = b.id and a.tid>500000 limit 200;

2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。

select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;


